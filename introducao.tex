\chapter{Introdução}

A meteorologia é uma das áreas que mais exige poder computacional para alcançar seus objetivos. A previsão meteorológica é o exemplo mais claro disso. Tal tarefa necessita de supercomputadores, como por exemplo o novo supercomputador Cray XT-6 adquirido pelo CPTEC/INPE\footnote{Centro de Previsão de Tempo e Estudo Climáticos / Instituto Nacional de Pesquisas Espaciais} considerado um dos 50 mais rápidos do mundo, e equipes especializadas em otimizar o código-fonte dos programas para ser capaz de alcançar bons resultados. Isso acontece porque para alcançar tamanha precisão é necessário que os dados utilizados como base tenham uma resolução igualmente boa. Porém isso faz com que a quantidade de dados a ser processado seja muito maior, e assim elevando o tempo de execução.

Entretanto, o campo da meteorologia não se resume apenas a previsão atmosférica. Existem muitos laboratórios espalhados pelo mundo que realizam pesquisas igualmente importantes e que enfrentam problemas similares aos já citados. A diferença é que por um lado tais pesquisas não necessitam de dados com tanta precisão, mas que por outro não possuem tanto investimento para equipamentos melhores. Outra grande diferença é que nessas pesquisas são os próprios pesquisadores, normalmente da área de física ou engenharia, que escrevem e executam os programas. Uma consequência disso é que os programas normalmente não são escritos da forma mais eficiente, fazendo com que algoritmos simples tenham um tempo elevado de execução, e assim desperdiçando o hardware disponível.

Nesse trabalho serão estudados métodos para otimizar algoritmos de processamento e análise de dados atmosféricos com base em técnicas de programação paralela, visando auxiliar programadores com pouco experiência a reduzir o tempo de execução de algoritmos. 

Nos capítulos 2 e 3 serão descritos, respectivamente, os algoritmos utilizados como base para o estudo e a organização dos dados usados como entrada para esses algoritmos. No capítulo 4 serão detalhadas as implementações paralelas em OpenMP e em CUDA desses algoritmos. Os resultados dos testes dessas implementações serão demonstrados no capítulo 5. Por fim, no capítulo 6, será apresentado um modelo de código genérico que resolve o problema proposto de maneira simples e que pode ser usado para a conversão de outros algoritmos semelhantes.